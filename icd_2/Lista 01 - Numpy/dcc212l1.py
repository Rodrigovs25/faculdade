# -*- coding: utf-8 -*-
"""dcc212l1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/icd-ufmg/icd-ufmg.github.io/blob/master/listas/l1/dcc212l1.ipynb

# Lista 01 - Introdu√ßao e Revisao Numpy

[NumPy](http://numpy.org) e um pacote incrivelmente poderoso em Python, onipresente em qualquer projeto de ci√™ncia de dados. Possui forte integra√ßao com o [Pandas](http://pandas.pydata.org), outra ferramenta que iremos abordar na materia. NumPy adiciona suporte para matrizes multidimensionais e fun√ß√µes matem√°ticas que permitem que voc√™ execute facilmente c√°lculos de √°lgebra linear. Este notebook ser√° uma cole√ßao de exemplos de √°lgebra linear computados usando NumPy. 

## Numpy 

Para fazer uso de Numpy precisamos importar a biblioteca
"""

# -*- coding: utf8

import numpy as np

"""Quando pensamos no lado pr√°tico de ci√™ncia de dados, um aspecto chave que ajuda na implementa√ßao de novos algoritmos e a vetoriza√ßao. De forma simples, vetoriza√ßao consiste do uso de tipos como **escalar**, **vetor** e **matriz** para realizar uma computa√ßao mais eficaz (em tempo de execu√ßao).

Uma matriz e uma cole√ßao de valores, normalmente representada por uma grade ùëö √ó ùëõ, onde ùëö e o numero de linhas e ùëõ e o numero de colunas. Os comprimentos das arestas ùëö e ùëõ nao precisam ser necessariamente diferentes. Se tivermos ùëö = ùëõ, chamamos isso de matriz quadrada. Um caso particularmente interessante de uma matriz e quando ùëö = 1 ou ùëõ = 1. Nesse caso, temos um caso especial de uma matriz que chamamos de vetor. Embora haja um objeto de matriz em NumPy, faremos tudo usando matrizes NumPy porque elas podem ter dimens√µes maiores que 2. 

1. **Escalar:** Um vetor de zero dimens√µes
"""

1

"""2. **Vetor:** Representa uma dimensao

Abaixo vamos criar um vetor simples. Inicialmente, vamos criar uma lista.
"""

data_list = [3.5, 5, 2, 8, 4.2]

"""Observe o tipo da mesma."""

type(data_list)

"""Embora vetores e listas sejam parecidos, vetores Numpy sao otimizados para opera√ß√µes de √Ålgebra Linear. Ci√™ncia de Dados faz bastante uso de tais opera√ß√µes, sendo este um dos motivos da depend√™ncia em Numpy.

Abaixo criamos um vetor.
"""

data = np.array(data_list)
print(data)
print(type(data))

"""Observe como podemos somar o mesmo com um numero. Nao e possivel fazer tal opera√ßao com listas."""

data + 7

"""3. **Matrizes:** Representam duas dimens√µes."""

X = np.array([[2, 4],
              [1, 3]])
X

"""Podemos indexar as matrizes e os vetores."""

data[0]

X[0, 1] # aqui e primeira linha, segunda coluna

"""Podemos tambem criar vetores/matrizes de numeros aleatorios"""

X = np.random.randn(4, 3) # Gera numeros aleatorios de uma normal
print(X)

"""### Indexando

Pegando a primeira linha
"""

X[0] # observe que 0 e a linha 1, compare com o X[0, 1] de antes.

X[1] # segunda

X[2] # terceira

"""Observe como todos os tipos retornados sao `array`. Array e o nome generico de Numpy para vetores e matrizes.

`X[:, c]` pega uma coluna
"""

X[:, 0]

X[:, 1]

"""`X[um_vetor]` pega as linhas da matriz. `X[:, um_vetor]` pega as colunas"""

X[[0, 0, 1]] # observe que pego a primeira linha, indexada por 0, duas vezes

"""Abaixo pego a segunda a primeira coluna"""

X[:, [1, 0]]

"""### Indexa√ßao Booleana

`X[vetor_booleano]` retorna as linhas (ou colunas quando X[:, vetor_booleano]) onde o vetor e true
"""

X[[True, False, True, False]]

X[:, [False, True, True]]

"""### Reshape, Flatten e Ravel

Todo vetor ou matriz pode ser redimensionado. Observe como uma matriz abaixo de 9x8=72 elementos. Podemos redimensionar os mesmos para outros arrays de tamanho 72.
"""

X = np.random.randn(9, 8)

"""Criando uma matriz de 18x4."""

X.reshape((18, 4))

"""Ou um vetor de 72"""

X.reshape(72)

"""A chamada flatten e ravel faz a mesma coisa, criam uma visao de uma dimensao da matriz."""

X.flatten()

X.ravel()

"""As fun√ß√µes incorporadas ao NumPy podem ser facilmente chamadas em matrizes. A maioria das fun√ß√µes sao aplicadas a um elemento de array (como a multiplica√ßao escalar). Por exemplo, se chamarmos `log()` em um array, o logaritmo ser√° obtido de cada elemento. """

np.log(data)

"""Mean tira a media"""

np.mean(data)

"""Algumas fun√ß√µes podem ser chamadas direto no vetor, nem todas serao assim. O importante e ler a [documenta√ßao](http://numpy.org) e aprender. Com um pouco de pr√°tica voc√™ vai se acostumando."""

data.mean()

"""Abaixo temos a mediana,"""

np.median(data) # por exemplo, nao existe data.median(). Faz sentido? Nao. Mas e assim.

"""Em matrizes as fun√ß√µes operam em todos os elemntos."""

np.median(X)

X.mean()

np.log(X + 10)

"""Porem, caso voc√™ queira a media de linhas ou colunas use `axis`. Antes, vamos ver o tamanho do vetor."""

X.shape

np.mean(X, axis=0) # media das colunas. como temos 8 colunas, temos 8 elementos.

np.mean(X, axis=0).shape

np.mean(X, axis=1) # media das linhas

np.mean(X, axis=1).shape

"""Lembre-se que eixo 0 e coluna. Eixo 1 e linas.

### Multiplica√ßao de Matrizes

Para transpor uma matriz fazemos uso de .T
"""

X.shape

X.T.shape

X.T

"""Para multiplicar matrizes, do ponto de visto de multiplica√ßao matricial como definido na √°lgebra linear, fazemos uso de `@`."""

X @ X.T

"""O uso de `*` realiza uma opera√ßao ponto a ponto"""

X * X

"""Observe a diferen√ßa de tamanhos"""

(X * X).shape

(X @ X.T).shape

"""**Pense:** Para o nosso `X` de tamanho `(9, 8)`, qual o motivo de `X * X.T` nao funcionar? Qual o motivo de `X @ X` nao funcionar?

## Corre√ßao Autom√°tica

Nossa corre√ßao autom√°tica depende das fun√ß√µes abaixo. Tais fun√ß√µes comparam valores que serao computados pelo seu codigo com uma saida esperada. Normalmente, voc√™s nao fazer uso de tais fun√ß√µes em notebooks como este. Porem, elas sao chave em ambientes de testes autom√°ticos (fora do nosso escopo).

Observe como algumas fun√ß√µes comparam valores e outras comparam vetores. Alem do mais, temos fun√ß√µes para comparar dentro de algumas casas decimais.
"""

from numpy.testing import assert_almost_equal
from numpy.testing import assert_equal

from numpy.testing import assert_array_almost_equal
from numpy.testing import assert_array_equal

# caso voc√™ mude um dos valores vamos receber um erro!
assert_array_equal(2, 2)

# caso voc√™ mude um dos valores vamos receber um erro!
assert_array_equal([1, 2], [1, 2])

# caso voc√™ mude um dos valores vamos receber um erro!
assert_almost_equal(3.1415, 3.14, 1)

"""Caso voc√™ mude um dos valores abaixo vamos receber um erro! Como o abaixo.

```
-----------------------------------------------------------------------
AssertionError                        Traceback (most recent call last)
<ipython-input-10-396672d880f2> in <module>
----> 1 assert_equal(2, 3) # caso voc√™ mude um dos valores vamos receber um erro!

~/miniconda3/lib/python3.7/site-packages/numpy/testing/_private/utils.py in assert_equal(actual, desired, err_msg, verbose)
    413         # Explicitly use __eq__ for comparison, gh-2552
    414         if not (desired == actual):
--> 415             raise AssertionError(msg)
    416 
    417     except (DeprecationWarning, FutureWarning) as e:

AssertionError: 
Items are not equal:
 ACTUAL: 2
 DESIRED: 3
 ```

e essencial que todo seu codigo execute sem erros! Portanto, antes de submeter clique em `Kernel` no menu acima. Depois clique em `Restart & Execute All.`

**Garanta que o notebook executa ate o fim!** Isto e, sem erros como o acima.

## Fun√ß√µes em Python

Para criar uma fun√ßao em Python fazemos uso da palavra-chave: 
```python
def
```

Todos nossos exercicios farao uso de fun√ß√µes. **Mantenha a assinatura das fun√ß√µes exatamente como requisitado, a corre√ßao autom√°tica depende disso.** Abaixo, temos um exempo de uma fun√ßao que imprime algo na tela!
"""

def print_something(txt):
    print(f'Voce passou o argumento: {txt}')

print_something('DCC 212')

"""Podemos tambem dizer o tipo do argumento, porem faremos pouco uso disto em ICD."""

def print_something(txt: str):
    print(f'Voce passou o argumento: {txt}')

print_something('DCC 212')

"""Abaixo temos uma fun√ßao que soma, a soma, dois vetores"""

def sum_of_sum_vectors(array_1, array_2):
    return (array_1 + array_2).sum()

x = np.array([1, 2])
y = np.array([1, 2])

sum_of_sum_vectors(x, y)

"""Abaixo temos um teste, tais testes vao avaliar o seu codigo. Nem todos estao aqui no notebook!"""

assert_equal(6, sum_of_sum_vectors(x, y))

"""## Exercicio 01

Inicialmente, crie uma fun√ßao que recebe duas listas de numeros, converte as duas para um vetor numpy usando `np.array` e retorna o produto interno das duas listas. 

__Dicas:__  
1. Tente fazer um codigo sem nenhum **for**! Ou seja, numpy permite opera√ß√µes em vetores e matrizes, onde: `np.array([1, 2]) + np.array([2, 2]) = np.array([3, 4])`.

__Fun√ß√µes:__
1. `np.sum(array)` soma os elementos do array. `array.sum()` tem o mesmo efeito!
"""

def inner(array_1, array_2):
    prod = array_1 * array_2
    return np.sum(prod)

x1 = np.array([2, 4, 8])
x2 = np.array([10, 100, 1000])
assert_equal(20 + 400 + 8000, inner(x1, x2))

"""## Exercicio 02

Implemente uma fun√ßao utilizando numpy que recebe duas matrizes, multiplica as duas e retorne o valor medio das celulas da multiplica√ßao. Por exemplo, ao multiplicar:

```
[1 2]
[3 4] 

com 

[2 1]
[1 2]

temos

[4  5 ]
[10 11]

onde a media de [4, 5, 10, 11] e

7.5, sua resposta final!
```


__Dicas:__  
1. Use o operador @ para multiplicar matrizes!
"""

def medmult(X_1, X_2):
  z = X_1 @ X_2
  return np.mean(z)

X = np.array([1, 2, 3, 4]).reshape(2, 2)
Y = np.array([2, 1, 1, 2]).reshape(2, 2)
assert_equal(7.5, medmult(X, Y))

